#include <stdio.h>
#include <memory.h>
#include <stdlib.h>

typedef unsigned char* BytePtr;
typedef struct {
  unsigned char key[16];  //128 bit key
  unsigned char iv[12];   //96 bit IV
  unsigned char ls[256]; //Shift register
  unsigned int ctr;
} espresso_ctx;
int update_ls(espresso_ctx *ctx, unsigned char init) {
  unsigned char  out;
  unsigned char *ls = ctx->ls;
  unsigned char n[256];
  memset(n, 0, 256);
  // Save new variables and output
  out  = ls[80] ^ ls[99] ^ ls[137] ^ ls[227] ^ ls[222] ^ ls[187] ^ \
         ls[243]&ls[217] ^ ls[247]&ls[231] ^ ls[213]&ls[235] ^ \
         ls[255]&ls[251] ^ ls[181]&ls[239] ^ ls[174]&ls[44]  ^  \
         ls[164]&ls[29]  ^ ls[255]&ls[247]&ls[243]&ls[213]&ls[181]&ls[174];
  n[255] = ls[0] ^ ls[41]&ls[70];
  n[251] = ls[42]&ls[83]  ^ ls[8];
  n[247] = ls[44]&ls[102] ^ ls[40];
  n[243] = ls[43]&ls[118] ^ ls[103];
  n[239] = ls[46]&ls[141] ^ ls[117];
  n[235] = ls[67]&ls[90]&ls[110]&ls[137];
  n[231] = ls[50]&ls[159] ^ ls[189];
  n[217] = ls[3]&ls[32];
  n[213] = ls[4]&ls[45];
  n[209] = ls[6]&ls[64];
  n[205] = ls[5]&ls[80];
  n[201] = ls[8]&ls[103];
  n[197] = ls[29]&ls[52]&ls[72]&ls[99];
  n[193] = ls[12]&ls[121];
  if (init) {
	  n[255] ^= out;
	  n[217] ^= out;
  }
  for (int i = 0; i < 255; i++)
  {
    ls[i] = ls[i+1] ^ n[i];
  }
  ls[255] = n[255];
  return out;
}
int init_ls(espresso_ctx *ctx, int numRounds) {
  unsigned int i,j;
  unsigned char *ls = ctx->ls;
  // Load key and IV
  for (i=0;i<16;i++) for (j=0;j<8;j++) ls[8*i + j] = (((ctx->key[i])>>j)&1);
  for (i=0;i<12;i++) for (j=0;j<8;j++) ls[128 + 8*i + j] = (((ctx->iv[i])>>j)&1);
  for (i=0;i<31;i++) ls[128+96+i] = 1;
  ls[255] = 0;
  ctx->ctr=0;
  for (i=0;i<numRounds;i++) update_ls(ctx,1);
  return 0;
}
int main() {
	int i, j;
	espresso_ctx ctx;
	unsigned char *keystream;
	keystream = (unsigned char *)malloc(2000);
	memset(keystream, 0, 2000);
	//for (i=0;i<16;++i) (&ctx)->key[i] = (unsigned char) i;
    //    for (i=0;i<12;++i) (&ctx)->iv[i] = (unsigned char) i;
    (&ctx)->key[0] = (unsigned char) 15; //4a
    (&ctx)->key[1] = (unsigned char) 14;  //06
    (&ctx)->key[2] = (unsigned char) 13; //5d
    (&ctx)->key[3] = (unsigned char) 12;  //07
    (&ctx)->key[4] = (unsigned char) 11; //4b
    (&ctx)->key[5] = (unsigned char) 10; //cd
    (&ctx)->key[6] = (unsigned char) 9; //ba
    (&ctx)->key[7] = (unsigned char) 8; //e3
    (&ctx)->key[8] = (unsigned char) 7;  //4e
    (&ctx)->key[9] = (unsigned char) 6;  //42
    (&ctx)->key[10] = (unsigned char) 5;  //02
    (&ctx)->key[11] = (unsigned char) 4; //5f
    (&ctx)->key[12] = (unsigned char) 3;  //04
    (&ctx)->key[13] = (unsigned char) 2;  //06
    (&ctx)->key[14] = (unsigned char) 1; //b0
    (&ctx)->key[15] = (unsigned char) 0; //d5
    
    (&ctx)->iv[0] = (unsigned char) 15; //fd
    (&ctx)->iv[1] = (unsigned char) 14; //20
    (&ctx)->iv[2] = (unsigned char) 13; //b5
    (&ctx)->iv[3] = (unsigned char) 12; //2e
    (&ctx)->iv[4] = (unsigned char) 11; //bb
    (&ctx)->iv[5] = (unsigned char) 10; //07
    (&ctx)->iv[6] = (unsigned char) 9; //27
    (&ctx)->iv[7] = (unsigned char) 8; //d6
    (&ctx)->iv[8] = (unsigned char) 7; //a1
    (&ctx)->iv[9] = (unsigned char) 6; //f5
    (&ctx)->iv[10] = (unsigned char) 5; //33
    (&ctx)->iv[11] = (unsigned char) 4; //2e
    
	// Initiate cipher
  	init_ls(&ctx, 256);
	for (i=0;i<256;++i) for (j=0;j<8;++j) keystream[i] ^= (update_ls(&ctx,0)<<j);
	
	// Print keystream bytes
  for (i=0;i<256;++i) printf("%02X",keystream[i]);
  printf("\n");

	return 0;

}
/*
CE0924E2996B0F03E78B9953DD9F07B43369319B4F793276E146EABB87518A60F5E250E1C504658669D05D1D5638F476069A6B8F0A896E01971E7439EB3F8807F49671CD62CCF7AB19A323AC9239560282579F028A0DAE943F8465E06B2D4FF59F4377480EF2AAE455F9A3FCE1E50FCFE29B5F933D907597556410C6D6E5EAE814B5E6020CC1CC1018DAE24EB7B3C089A77BA1A3077686DE2B8DFAD2DA9DF4FA6854FF95AB30263E8843560A6FDD2ECA97E56B962876C64288B73B3266C44D1A04FCE7F4F3AE7BD56D6D12721CF602E5681D9F642400B74C72ED654529DC72E4F325BFAF51E3A9118414B37CDC6D2D6CB913E73974725EE928CA787E078D27A587856DF5FBC4EE9275EA05FC9948552C45B29C7153636A9ED4372BBE2DA284D2783638BC8F4C3E02E83B3C128D07B467B54891CF5501E5ED708B0AB0921DA12389337E3D262BD4A3D32750FC76EEF5109F6DA2498DC1992820522AF849F6844B93C400CA6A2A473A9EBB44ED3EBE253C6B80844B0CEFD8B2A08C91EE12D8592A66BE5B6C6725D0A8BBE8DB3FF4BCEBED92E935E1F80B6B2B1494C036806029EFD4073796878B3A4E3AFF686D756282E834AD74DE9086F2D03B87DED0142D31D704E064DB63D4096D2D8E97466AF905AB1E41F8FB2BED0E955E5EC8A7C7899301FD0DCD41B20E47D91041DFA09E7422E112F1437BE366A0FD3CA7FA14B863643FF60B45DF7E482C69DE77946D749E93AA52891FE8FA3032F41734B5A55A1EC10FE480B52DCDA04F646EC72D12B34C1FA40ED31088F3912C54C9564927ED596958D4FCCA02B79265694057DD72E3235EB26F1545619B490130255CEF784A664AD81A3FDF16A9FAE9F1081D0D600AA27AD49DD051039957FA1AE09D45342012D57A5D65A2227F1B5D90EF1AE4CF23CEE6F83C2746E9727AE8003D351D9341B610F596536AD96DE8B62D6ACA339F090DE28BD5C830B6549402875EAE2EFD747EB6CD3C62724FF32A8BDF07E61AD100ABCC43A3ADB49A57D9116C730A18472F95B1043CF4F5C9095F3F33A8F3F5BBB3B53268B0717B857BAADB224EE7EC3BBDBB7AEA4542F9C6495D8563ADF04B724B330593FD07FA96ED1468685E364DE89733E61EE5371270F43D3DDC86621677933F7520EED5594219BE83BE600A314D5F26D5A69D92E304EA32273001A9E48D5F1ECFA374CFBA2F8B229FA43D7C7D0F5D6EE0D0FAC613D5A1E8E1726DBFD03E0F289EB503E50666930F6BCC2EF1EF9642809A008557013B146DD0707F5FDCE1D3AB085410A96856E8FAC6E513E4660F7A9E474BA481BCAE168108FCBC6577AD83BC39C629941D3662DE147558E596AEF481C444FD2AD46B2841E86C48C22341F67CD166F37CE1E4F27A51CEB6EC3A5F6BFC074328AD7162F3D2BCBD57E0DFABA9F9CFEC8DD3F39EABD4E962A2676C4AFC55A3FB7118C728F7C5EE3A997B61541757C585B4AA7BA546D22975D0FA3800E840C0FD22CBA3508289D9793553EE0EB02611B20CA424844C55AF57D4F5BB0309076A69FDE905FFC60B427B834FBED3EFFBE4DEA76C28F078767120D15864449112B766EAAADC1C06144DDDD35FEE12601677B01D83CA42682BCAB34B053C1DD7997D2EC375958810DBEBDCEB8CB6DD0B1AEC0C97F04925B2B46DB27241F2B667C583C8FC647D2847FDF7DE87B6CC7079FCD7F65783D1624501187DE65512F732E148E39F2BC5F9D10F2891ABE0842925EBC3349FA2A1EFCFAB03ED62CA62F7F8F8C659D5341FE46570A2B3989CD0FF8AF871E878C1D1D4E15EFC023E189466EF102C94A5E21D8490C51079D3B00D84DCB93976C5B923D77FCDBDFB007FC186B23F52C9CABFA3DFAE0D0A487EDE3A87C351B776A9E09E68C9900E3B080A8242092B052EB8ACDE5DB125BCCE977EF96E06279C78F8E86784404E47A275CD4E11A35693BA5181C6E4E4F9504926015E30DAD1C875A7E973860CE104D8A12A8CF4B670B6B350C48DCBD5EBA303FE3954A7E58730AA5448FCE6858AC5348D301A1E698F6CC96B73DDAC1050FF4CFB0EDC06F8AB1E66D497DFE6DB55E7303CDFBB5A097A23B1FCA55C3B651CD7319D507479BC87180DF1FB67627A694F7F2064C751D9BC3CA1ACB26A71B128C1B9115EF9C4D535E28FED5105421395F5CCD4EBB9952C153AD97F8C3C443527CFB8258F88A9C2417062D8EB8E3AA6EB394D75C1D61613A7C0858E681A163E128AE040FC9AA9E715B22DFC71407BCDBB9BAE21C80913397449703CEA025AC174991A973CB6B29B816CCA8F8030F90E012E5E26782C5552A469D436969F807E3706E337C2C1539539ADC5A0D2E49854EF5F0A185120898DDA21CCD8CC03533DFA6098CC2DC024C74C03519AC808762E6E2184EA689FC8D29F3455B6F35B83F81C412B30F82CD01F67951B80E0EC38BBA6506CCC64B255ECA89D5D2720E84F57099BEFDEA151CDA156734592DBA1D7956F8B75FED25D928EC8FA0B8BA374865598A36275A98D507D09017C2C439965A92118310D3FC3182C4A62A0B2B2FF4A9ED747B7D3D1694F4E9A2EE2DABB8C77F4B9B9A6D6FACF8CBE75C2373A03B7315848AC186A6D7421B9573DBDFCBB54C376647263607D5FB18E970018D593E853FDAE52100D15DDBA4B704AC6A775B7023FAEA16314457E04C1FB4DD723F5353E27ACC5E516302F59DAC5982CA9B55D9114DA9D8BEEBFFFBDF64C32CF6D5424BEE98857F41923C10C6D4A770DBBBEC86F240D7100AACAA4253129C03825A69EC2F9B68A6317AF008070E418006B1B922944A6981E30F70D13A58A1406326384546E4E612DEBF92883432F4794
*/